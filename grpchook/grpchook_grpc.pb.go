// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package grpchook

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RpcHookClient is the client API for RpcHook service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RpcHookClient interface {
	// Client
	ClientConnect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	ClientConnack(ctx context.Context, in *ConnackRequest, opts ...grpc.CallOption) (*ConnackResponse, error)
	ClientConnected(ctx context.Context, in *ConnectedRequest, opts ...grpc.CallOption) (*ConnectedResponse, error)
	ClientDisconnected(ctx context.Context, in *DisconnectedRequest, opts ...grpc.CallOption) (*DisconnectedResponse, error)
	ClientAuthenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error)
	ClientCheckAcl(ctx context.Context, in *CheckAclRequest, opts ...grpc.CallOption) (*CheckAclResponse, error)
	ClientSubscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	ClientUnsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// Session
	SessionCreated(ctx context.Context, in *SessionCreatedRequest, opts ...grpc.CallOption) (*SessionCreatedResponse, error)
	SessionSubscribed(ctx context.Context, in *SessionSubscribedRequest, opts ...grpc.CallOption) (*SessionSubscribedResponse, error)
	SessionUnsubscribed(ctx context.Context, in *SessionUnsubscribedRequest, opts ...grpc.CallOption) (*SessionUnsubscribedResponse, error)
	SessionTerminated(ctx context.Context, in *SessionTerminatedRequest, opts ...grpc.CallOption) (*SessionTerminatedResponse, error)
	// Message
	MessagePublish(ctx context.Context, in *MessagePublishRequest, opts ...grpc.CallOption) (*MessagePublishResponse, error)
	MessageDelivered(ctx context.Context, in *MessageDeliveredRequest, opts ...grpc.CallOption) (*MessageDeliveredResponse, error)
	MessageAcked(ctx context.Context, in *MessageAckedRequest, opts ...grpc.CallOption) (*MessageAckedResponse, error)
	MessageDropped(ctx context.Context, in *MessageDroppedRequest, opts ...grpc.CallOption) (*MessageDroppedResponse, error)
}

type rpcHookClient struct {
	cc grpc.ClientConnInterface
}

func NewRpcHookClient(cc grpc.ClientConnInterface) RpcHookClient {
	return &rpcHookClient{cc}
}

func (c *rpcHookClient) ClientConnect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) ClientConnack(ctx context.Context, in *ConnackRequest, opts ...grpc.CallOption) (*ConnackResponse, error) {
	out := new(ConnackResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientConnack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) ClientConnected(ctx context.Context, in *ConnectedRequest, opts ...grpc.CallOption) (*ConnectedResponse, error) {
	out := new(ConnectedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientConnected", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) ClientDisconnected(ctx context.Context, in *DisconnectedRequest, opts ...grpc.CallOption) (*DisconnectedResponse, error) {
	out := new(DisconnectedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientDisconnected", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) ClientAuthenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error) {
	out := new(AuthenticateResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientAuthenticate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) ClientCheckAcl(ctx context.Context, in *CheckAclRequest, opts ...grpc.CallOption) (*CheckAclResponse, error) {
	out := new(CheckAclResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientCheckAcl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) ClientSubscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientSubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) ClientUnsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/ClientUnsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) SessionCreated(ctx context.Context, in *SessionCreatedRequest, opts ...grpc.CallOption) (*SessionCreatedResponse, error) {
	out := new(SessionCreatedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/SessionCreated", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) SessionSubscribed(ctx context.Context, in *SessionSubscribedRequest, opts ...grpc.CallOption) (*SessionSubscribedResponse, error) {
	out := new(SessionSubscribedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/SessionSubscribed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) SessionUnsubscribed(ctx context.Context, in *SessionUnsubscribedRequest, opts ...grpc.CallOption) (*SessionUnsubscribedResponse, error) {
	out := new(SessionUnsubscribedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/SessionUnsubscribed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) SessionTerminated(ctx context.Context, in *SessionTerminatedRequest, opts ...grpc.CallOption) (*SessionTerminatedResponse, error) {
	out := new(SessionTerminatedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/SessionTerminated", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) MessagePublish(ctx context.Context, in *MessagePublishRequest, opts ...grpc.CallOption) (*MessagePublishResponse, error) {
	out := new(MessagePublishResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/MessagePublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) MessageDelivered(ctx context.Context, in *MessageDeliveredRequest, opts ...grpc.CallOption) (*MessageDeliveredResponse, error) {
	out := new(MessageDeliveredResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/MessageDelivered", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) MessageAcked(ctx context.Context, in *MessageAckedRequest, opts ...grpc.CallOption) (*MessageAckedResponse, error) {
	out := new(MessageAckedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/MessageAcked", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcHookClient) MessageDropped(ctx context.Context, in *MessageDroppedRequest, opts ...grpc.CallOption) (*MessageDroppedResponse, error) {
	out := new(MessageDroppedResponse)
	err := c.cc.Invoke(ctx, "/grpchook.RpcHook/MessageDropped", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RpcHookServer is the server API for RpcHook service.
// All implementations must embed UnimplementedRpcHookServer
// for forward compatibility
type RpcHookServer interface {
	// Client
	ClientConnect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	ClientConnack(context.Context, *ConnackRequest) (*ConnackResponse, error)
	ClientConnected(context.Context, *ConnectedRequest) (*ConnectedResponse, error)
	ClientDisconnected(context.Context, *DisconnectedRequest) (*DisconnectedResponse, error)
	ClientAuthenticate(context.Context, *AuthenticateRequest) (*AuthenticateResponse, error)
	ClientCheckAcl(context.Context, *CheckAclRequest) (*CheckAclResponse, error)
	ClientSubscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	ClientUnsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// Session
	SessionCreated(context.Context, *SessionCreatedRequest) (*SessionCreatedResponse, error)
	SessionSubscribed(context.Context, *SessionSubscribedRequest) (*SessionSubscribedResponse, error)
	SessionUnsubscribed(context.Context, *SessionUnsubscribedRequest) (*SessionUnsubscribedResponse, error)
	SessionTerminated(context.Context, *SessionTerminatedRequest) (*SessionTerminatedResponse, error)
	// Message
	MessagePublish(context.Context, *MessagePublishRequest) (*MessagePublishResponse, error)
	MessageDelivered(context.Context, *MessageDeliveredRequest) (*MessageDeliveredResponse, error)
	MessageAcked(context.Context, *MessageAckedRequest) (*MessageAckedResponse, error)
	MessageDropped(context.Context, *MessageDroppedRequest) (*MessageDroppedResponse, error)
	mustEmbedUnimplementedRpcHookServer()
}

// UnimplementedRpcHookServer must be embedded to have forward compatible implementations.
type UnimplementedRpcHookServer struct {
}

func (UnimplementedRpcHookServer) ClientConnect(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientConnect not implemented")
}
func (UnimplementedRpcHookServer) ClientConnack(context.Context, *ConnackRequest) (*ConnackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientConnack not implemented")
}
func (UnimplementedRpcHookServer) ClientConnected(context.Context, *ConnectedRequest) (*ConnectedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientConnected not implemented")
}
func (UnimplementedRpcHookServer) ClientDisconnected(context.Context, *DisconnectedRequest) (*DisconnectedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientDisconnected not implemented")
}
func (UnimplementedRpcHookServer) ClientAuthenticate(context.Context, *AuthenticateRequest) (*AuthenticateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientAuthenticate not implemented")
}
func (UnimplementedRpcHookServer) ClientCheckAcl(context.Context, *CheckAclRequest) (*CheckAclResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientCheckAcl not implemented")
}
func (UnimplementedRpcHookServer) ClientSubscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientSubscribe not implemented")
}
func (UnimplementedRpcHookServer) ClientUnsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClientUnsubscribe not implemented")
}
func (UnimplementedRpcHookServer) SessionCreated(context.Context, *SessionCreatedRequest) (*SessionCreatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionCreated not implemented")
}
func (UnimplementedRpcHookServer) SessionSubscribed(context.Context, *SessionSubscribedRequest) (*SessionSubscribedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionSubscribed not implemented")
}
func (UnimplementedRpcHookServer) SessionUnsubscribed(context.Context, *SessionUnsubscribedRequest) (*SessionUnsubscribedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionUnsubscribed not implemented")
}
func (UnimplementedRpcHookServer) SessionTerminated(context.Context, *SessionTerminatedRequest) (*SessionTerminatedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionTerminated not implemented")
}
func (UnimplementedRpcHookServer) MessagePublish(context.Context, *MessagePublishRequest) (*MessagePublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessagePublish not implemented")
}
func (UnimplementedRpcHookServer) MessageDelivered(context.Context, *MessageDeliveredRequest) (*MessageDeliveredResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageDelivered not implemented")
}
func (UnimplementedRpcHookServer) MessageAcked(context.Context, *MessageAckedRequest) (*MessageAckedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageAcked not implemented")
}
func (UnimplementedRpcHookServer) MessageDropped(context.Context, *MessageDroppedRequest) (*MessageDroppedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageDropped not implemented")
}
func (UnimplementedRpcHookServer) mustEmbedUnimplementedRpcHookServer() {}

// UnsafeRpcHookServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RpcHookServer will
// result in compilation errors.
type UnsafeRpcHookServer interface {
	mustEmbedUnimplementedRpcHookServer()
}

func RegisterRpcHookServer(s grpc.ServiceRegistrar, srv RpcHookServer) {
	s.RegisterService(&RpcHook_ServiceDesc, srv)
}

func _RpcHook_ClientConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientConnect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_ClientConnack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientConnack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientConnack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientConnack(ctx, req.(*ConnackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_ClientConnected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientConnected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientConnected",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientConnected(ctx, req.(*ConnectedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_ClientDisconnected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientDisconnected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientDisconnected",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientDisconnected(ctx, req.(*DisconnectedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_ClientAuthenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientAuthenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientAuthenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientAuthenticate(ctx, req.(*AuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_ClientCheckAcl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAclRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientCheckAcl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientCheckAcl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientCheckAcl(ctx, req.(*CheckAclRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_ClientSubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientSubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientSubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientSubscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_ClientUnsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).ClientUnsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/ClientUnsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).ClientUnsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_SessionCreated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionCreatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).SessionCreated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/SessionCreated",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).SessionCreated(ctx, req.(*SessionCreatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_SessionSubscribed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionSubscribedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).SessionSubscribed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/SessionSubscribed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).SessionSubscribed(ctx, req.(*SessionSubscribedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_SessionUnsubscribed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUnsubscribedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).SessionUnsubscribed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/SessionUnsubscribed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).SessionUnsubscribed(ctx, req.(*SessionUnsubscribedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_SessionTerminated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionTerminatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).SessionTerminated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/SessionTerminated",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).SessionTerminated(ctx, req.(*SessionTerminatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_MessagePublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagePublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).MessagePublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/MessagePublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).MessagePublish(ctx, req.(*MessagePublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_MessageDelivered_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageDeliveredRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).MessageDelivered(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/MessageDelivered",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).MessageDelivered(ctx, req.(*MessageDeliveredRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_MessageAcked_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageAckedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).MessageAcked(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/MessageAcked",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).MessageAcked(ctx, req.(*MessageAckedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcHook_MessageDropped_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageDroppedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcHookServer).MessageDropped(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpchook.RpcHook/MessageDropped",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcHookServer).MessageDropped(ctx, req.(*MessageDroppedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RpcHook_ServiceDesc is the grpc.ServiceDesc for RpcHook service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RpcHook_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpchook.RpcHook",
	HandlerType: (*RpcHookServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ClientConnect",
			Handler:    _RpcHook_ClientConnect_Handler,
		},
		{
			MethodName: "ClientConnack",
			Handler:    _RpcHook_ClientConnack_Handler,
		},
		{
			MethodName: "ClientConnected",
			Handler:    _RpcHook_ClientConnected_Handler,
		},
		{
			MethodName: "ClientDisconnected",
			Handler:    _RpcHook_ClientDisconnected_Handler,
		},
		{
			MethodName: "ClientAuthenticate",
			Handler:    _RpcHook_ClientAuthenticate_Handler,
		},
		{
			MethodName: "ClientCheckAcl",
			Handler:    _RpcHook_ClientCheckAcl_Handler,
		},
		{
			MethodName: "ClientSubscribe",
			Handler:    _RpcHook_ClientSubscribe_Handler,
		},
		{
			MethodName: "ClientUnsubscribe",
			Handler:    _RpcHook_ClientUnsubscribe_Handler,
		},
		{
			MethodName: "SessionCreated",
			Handler:    _RpcHook_SessionCreated_Handler,
		},
		{
			MethodName: "SessionSubscribed",
			Handler:    _RpcHook_SessionSubscribed_Handler,
		},
		{
			MethodName: "SessionUnsubscribed",
			Handler:    _RpcHook_SessionUnsubscribed_Handler,
		},
		{
			MethodName: "SessionTerminated",
			Handler:    _RpcHook_SessionTerminated_Handler,
		},
		{
			MethodName: "MessagePublish",
			Handler:    _RpcHook_MessagePublish_Handler,
		},
		{
			MethodName: "MessageDelivered",
			Handler:    _RpcHook_MessageDelivered_Handler,
		},
		{
			MethodName: "MessageAcked",
			Handler:    _RpcHook_MessageAcked_Handler,
		},
		{
			MethodName: "MessageDropped",
			Handler:    _RpcHook_MessageDropped_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpchook.proto",
}
